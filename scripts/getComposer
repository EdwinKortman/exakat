<?php

$project = $argv[1];
if (empty($project)) {
    die( "getComposer <project>\n");
}
if (!file_exists('./projects/'.$project.'')) {
    die( "No such project as $project\n");
}

if (!file_exists('./projects/'.$project.'/code/composer.json')) {
    die( "No composer for project $project\n");
}

$composer = json_decode(file_get_contents("projects/$project/code/composer.json"));
$components = array_merge((array) @$composer->require,
                          (array) @$composer->{'require-dev'},
                          (array) @$composer->suggest);

unset($components['php']);
foreach($components as $k => $v) {
    if (substr($k, 0, 4) == 'ext-') {
        unset($components[$k]);
    }

    if (substr($k, 0, 4) == 'lib-') {
        unset($components[$k]);
    }
}

print "About to check for ".count($components)." components\n";
foreach($components as $fullName => $version) {
    print " + $fullName\n";
}

$sqlite = new sqlite3('data/composer.sqlite');

if (in_array('-t', $argv)) {
    foreach($components as $fullName => $version) {
        list($vendor, $component) = explode('/', strtolower($fullName));
    
        $res = $sqlite->query(<<<SQL
    SELECT components.id, group_concat(version) FROM components 
              JOIN versions
                ON versions.component_id = components.id
            WHERE vendor='$vendor' AND 
                  component = '$component'
            ORDER BY version DESC
SQL
    );

        $row = $res->fetchArray(SQLITE3_NUM);
        $numRows = 1;
        while($res->fetchArray(SQLITE3_NUM)) { ++$numRows; }
        print $numRows." lines for $vendor/$component\n";

        list($res, $dbVersion) = $row;
        if ($res) {
            $componentId = $res;
            print "$vendor/$component already in reference ($version / ".substr($dbVersion, 0, 50).")\n";
        } else {
            print "$vendor/$component is not yet in the database\n";
        }
    }
    die();
}

foreach($components as $fullName => $version) {
    list($vendor, $component) = explode('/', strtolower($fullName));
    
    processComponent($vendor, $component, $version);
}

$res = $sqlite->query("SELECT count(*) AS nb FROM components");
print $res->fetchArray(SQLITE3_ASSOC)['nb']." components\n";
$res = $sqlite->query("SELECT count(*) AS nb FROM versions");
print $res->fetchArray(SQLITE3_ASSOC)['nb']." versions\n";
$res = $sqlite->query("SELECT count(*) AS nb FROM classes");
print $res->fetchArray(SQLITE3_ASSOC)['nb']." classes\n";
$res = $sqlite->query("SELECT count(*) AS nb FROM interfaces");
print $res->fetchArray(SQLITE3_ASSOC)['nb']." interfaces\n";
$res = $sqlite->query("SELECT count(*) AS nb FROM traits");
print $res->fetchArray(SQLITE3_ASSOC)['nb']." traits\n";

unset($sqlite);
// print "Optimize database\n";
//print shell_exec('robo check:composer');
shell_exec('sqlite3 my.db "VACUUM;"');

$count = 0;
foreach(glob(sys_get_temp_dir()."/exComposer*") as $tmpdir) {
    if (strpos($tmpdir, 'exComposer') === false) {
        continue;
    }
    ++$count;
    shell_exec( "rm -rf $tmpdir");
}
print "Removed $count temporary dirs\n";

function processComponent($vendor, $component, $version, $dir = '') {
    global $sqlite; 
    
    $res = $sqlite->query(<<<SQL
SELECT versions.version AS version, components.id AS id FROM components 
        JOIN versions 
            ON versions.component_id = components.id
        WHERE vendor='$vendor' AND 
              component = '$component'
        ORDER BY versions.version DESC
SQL
);

    $res = $res->fetchArray(SQLITE3_ASSOC);

    if ($res) {
        $componentId = $res['id'];
        print substr("$vendor/$component".str_repeat(' ', 50), 0, 50)."$version / {$res['version']}\n";
//        continue;
    } else {
        $date = time();
        $sqlite->query("INSERT INTO components (vendor, component, last_check) VALUES ('$vendor', '$component', $date);");
        $componentId = $sqlite->lastInsertRowID();
        print "$vendor/$component newly inserted in reference ($componentId)\n";
    }
    
    print "Reading $vendor/$component versions\n";
    $res = shell_exec('composer show '.$vendor.'/'.$component);

    // remove colors
    $res = preg_replace('/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]/s', '', $res);
    preg_match_all("#versions : (.*?)\n#s", $res, $r);
    $versions = explode(', ', $r[1][0]);

    $res = shell_exec('composer show '.$vendor.'/'.$component.' '.$version.' 2>&1');
    preg_match_all("#versions : (.*?)\n#s", $res, $r);
    $solvedVersions = explode(', ', $r[1][0]);
    foreach($solvedVersions as &$sv) {
        if ($sv[0] == 'v') { 
            $sv = substr($sv, 1);
        }
    }
    unset($sv);
    
    foreach($versions as $v) {
        if ($v[0] == 'v') { 
            $v = substr($v, 1);
        }

        $sqlite->query("INSERT OR IGNORE INTO versions (component_id, version) VALUES ($componentId, '$v');");
        if (in_array($v, $solvedVersions)) {
            print "testing $v in solvedVersions\n";
            // needsa a reading 
            $res = $sqlite->query("SELECT id FROM versions WHERE component_id = $componentId AND version= '$v';");
            
            $versionId = $res->fetchArray(SQLITE3_ASSOC)['id'];
        }
    }
            if (empty($versionId)) {
                print "SELECT id FROM versions WHERE component_id = $componentId AND version= '$v';\n$version requested\n";
                die();
            }

    if ($dir === '') {
        print "Fetching $vendor/$component\n";
        $composer = new stdClass();
        $composer->require = new stdClass();
        $composer->require->{$vendor.'/'.$component} = $version;
        $json = json_encode($composer);
    
        $tmpdir = tempnam(sys_get_temp_dir(), 'exComposer');
        unlink($tmpdir);
        mkdir($tmpdir, 0755);
        file_put_contents($tmpdir.'/composer.json', $json);

        print shell_exec("cd $tmpdir; composer update");

        print $tmpdir.'/vendor/'.$vendor.'/'.$component."\n";
    } else {
        $tmpdir = $dir;
        
        print "Reusing dir $tmpdir\n";
    }
    
    $files = recursiveReaddir($tmpdir.'/vendor/'.$vendor.'/'.$component);
    $all = array();
    foreach($files as $file) {
        $all = array_merge_recursive($all, processFile($file));
    }
    
    print "$vendor/$component / $version ($componentId / $versionId)\n";

    $namespacesIds = array();
    foreach($all as $type => $objects) {
        foreach(array_keys($objects) as $ns) {
            if (!isset($namespacesIds[$ns])) {
                $ns = $sqlite->escapeString($ns);
                $res = $sqlite->query("SELECT id FROM namespaces WHERE version_id = '$versionId' AND namespace = '$ns'");
                $nsid = $res->fetchArray(SQLITE3_ASSOC)['id'];
                if ($nsid) {
                    $namespacesIds[$ns] = $nsid;
                } else {
                    $sqlite->query("INSERT INTO namespaces (version_id, namespace) VALUES ('$versionId', '$ns');");
                    $namespacesIds[$ns] = $sqlite->lastInsertRowID();
                    print "Insertion du namespace '$ns'\n";
                }
            }
        }
    }

    if (isset($all['Class'])) {
        foreach($all['Class'] as $ns => $classes) {
            foreach($classes as $class) {
                $res = $sqlite->query("SELECT id FROM classes WHERE namespace_id = '{$namespacesIds[$ns]}' AND classname = '$class'");
                $nsid = $res->fetchArray(SQLITE3_ASSOC)['id'];
                if ($nsid) {
    //                print "   $class found in $nsid\n";
                } else {
                    $sqlite->query("INSERT INTO classes (namespace_id, classname) VALUES ('{$namespacesIds[$ns]}', '$class');");
                    print "Insertion de la classe '$class'\n";
                }
            }
        }
    }

    if (isset($all['Interface'])) {
        foreach($all['Interface'] as $ns => $interfaces) {
            foreach($interfaces as $interface) {
                $res = $sqlite->query("SELECT id FROM interfaces WHERE namespace_id = '{$namespacesIds[$ns]}' AND interfacename = '$interface'");
                $nsid = $res->fetchArray(SQLITE3_ASSOC)['id'];
                if ($nsid) {
    //                print "   $class found in $nsid\n";
                } else {
                    $sqlite->query("INSERT INTO interfaces (namespace_id, interfacename) VALUES ('{$namespacesIds[$ns]}', '$interface');");
                }
            }
        }
    }

    if (isset($all['Trait'])) {
        foreach($all['Trait'] as $ns => $traits) {
            foreach($traits as $trait) {
                $res = $sqlite->query("SELECT id FROM traits WHERE namespace_id = '{$namespacesIds[$ns]}' AND traitname = '$trait'");
                $nsid = $res->fetchArray(SQLITE3_ASSOC)['id'];
                if ($nsid) {
    //                print "   $class found in $nsid\n";
                } else {
                    $sqlite->query("INSERT INTO traits (namespace_id, traitname) VALUES ('{$namespacesIds[$ns]}', '$trait');");
                }
            }
        }
    }
    
    if ($dir === '') {
        $installed = json_decode(file_get_contents($tmpdir.'/composer.lock'));
        
        foreach($installed->packages as $package) {
            list($subVendor, $subComponent) = explode('/', $package->name);
            if (substr($package->version, 0, 1) == 'v') {
                $package->version = substr($package->version, 1);
            }
            print " + $subVendor / $subComponent ".$package->version."\n";
            processComponent($subVendor, $subComponent, $package->version, $tmpdir);
        }
    }
}


function recursiveReaddir($tmpdir) {
    if (!file_exists($tmpdir)) { return array(); }
    $dir = opendir($tmpdir);
    $return = array();
    
    while($file = readdir($dir)) {
        if ($file[0] == '.') { continue; }
        
        if (is_dir($tmpdir.'/'.$file)) {
            $return = array_merge($return, recursiveReaddir($tmpdir.'/'.$file));
        } else {
            if (substr($file, -4) != '.php') { continue; }
            $return[] = $tmpdir.'/'.$file;
        }
    }
    
    return $return;
}

function processFile($file) {
    $tokens = token_get_all(file_get_contents($file));
    
    $return = array('Class' => array(),
                    'Interface' => array(),
                    'Trait' => array());
    $namespace = 'global';
    
    foreach($tokens as $id => $token) {
        if (is_array($token)) {
            switch($token[0]) {
                case T_NAMESPACE : 
                    $namespace = '';
                    for ($i = $id + 2; ($tokens[$i] != ';') && ($tokens[$i] != '{') && ($i - $id < 20); $i++) {
                        if (is_array($tokens[$i])) {
                            $namespace .= $tokens[$i][1];
                        } else {
                            $namespace .= $tokens[$i];
                        }
                    }
                    $namespace = trim($namespace);
                    break;

                case T_CLASS : 
                    // skip ::class 
                    if ($tokens[$id - 1][1] != '::') { 
                        $return['Class'][$namespace][] = $tokens[$id + 2][1];
                    }
                    break;

                case T_INTERFACE : 
                    $return['Interface'][$namespace][] = $tokens[$id + 2][1];
                    break;

                case T_TRAIT : 
                    $return['Trait'][$namespace][] = $tokens[$id + 2][1];
                    break;
                
                default : 
                    // nothing to do
                
            }
        }
    }
    
    return $return;
}

?>
