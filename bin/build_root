#!/usr/bin/env php
<?php
use Everyman\Neo4j\Client,
	Everyman\Neo4j\Index\NodeIndex,
	Everyman\Neo4j\Relationship,
	Everyman\Neo4j\Node,
	Everyman\Neo4j\Gremlin,
	Tokenizer\Token;

include_once(dirname(__DIR__).'/library/Autoload.php');
spl_autoload_register('Autoload::autoload_library');

if (in_array('-V', $argv)) {
    define('DISPLAY', true);
} else {
    define('DISPLAY', false);
}

if ($id = array_search('-p', $argv)) {
    $project = $argv[$id + 1];
} else {
    $project = 'None';
}

$begin = microtime(true);
$client = new Client();

logTime('Start');

$indices = array();
$res = query("g.getIndices()")->toArray();
foreach($res as $r) {
    $indices[] = substr($r[0], 7, strpos($r[0], ':') - 7);
}

$result = query("g.idx('racines')");
if ($result[0][0] != 'MANUAL[racines:Vertex]') {
    query("g.createManualIndex('racines', Vertex)");
}
if (DISPLAY) print "created racines index\n";

logTime('g.idx("racines")');

$indices = array();
$res = query("g.getIndices()")->toArray();
foreach($res as $r) {
    $indices[] = substr($r[0], 7, strpos($r[0], ':') - 7);
}
if (DISPLAY) print "getting all indices\n";

$faits = array();

$special_tokens = array('Integer', 'String', 'Identifier', 'Magicconstant',
                        'RawString', 'Variable', 'Float', 'Boolean');
$tokens = array_merge(Token::getTokenizers(), $special_tokens);

foreach($tokens as $id => $class) {
    $fullclass = "\\Tokenizer\\$class";
    if (!isset($fullclass::$atom)) {
        if (DISPLAY) print "$id) $class : missing token\n";
        continue;
    }
    if (DISPLAY) print "$id) $class : creating\n";
 
    $token = $fullclass::$atom;
    if (in_array($token, $faits)) {
        if (DISPLAY) print "$id) $class : already done as '$token'. Ignoring\n";
        continue; 
    } elseif (in_array($token, $indices)) {
        query("g.dropIndex('$token');");
    }

    query("g.createManualIndex('$token', Vertex)");
    $faits[] = $token;
    
    if (DISPLAY) print "$id) $class : created\n";
}
logTime('g.idx("classes")');

if (DISPLAY) print "$id) $class : filling\n";
$query = "g.V.filter{it.atom in ['Integer', 'String', 'Identifier', 'Magicconstant',
                                 'Rawstring', 'Variable', 'Float', 'Boolean']}.each{ 
                                 g.idx(it.atom).put('token', 'node', it); }";
query($query);
if (DISPLAY) print "$id) $class : filled\n";
logTime('g.idx("xxxxx") : filling');

// creating the neo4j Index
query("g.V.has('root', 'true').each{ g.idx('racines').put('token', 'ROOT', it); };");
logTime('g.idx("ROOT")');

if (DISPLAY) print "Indexing root done\n";

// special case for the initial Rawstring. 
query("g.idx('racines')[['token':'ROOT']].has('atom','Sequence').each{ g.idx('Sequence').put('token', 'node', it); };");
logTime('g.idx("Rawstring") special');

if (DISPLAY) print "Creating index done\n";

// creating the neo4j Index
query("g.V.has('token', 'INDEX').out('INDEXED').each{ g.idx('racines').put('token', it.token, it); };");
logTime('g.idx("racines")[[token:***]] indexing');

if (DISPLAY) print "Indexing racines done\n";

// calculating the Unicode blocks
query("g.idx('String')[['token':'node']].filter{it.code.replaceAll(/^['\"]/, '').size() > 0}.each{ it.setProperty('unicode_block', it.code.replaceAll(/^['\"]/, '').toList().groupBy{ Character.UnicodeBlock.of( it as char ).toString() }.sort{-it.value.size}.find{true}.key.toString()); };");
query("g.idx('Rawstring')[['token':'node']].filter{it.code.replaceAll(/^['\"]/, '').size() > 0}.each{ it.setProperty('unicode_block', it.code.replaceAll(/^['\"]/, '').toList().groupBy{ Character.UnicodeBlock.of( it as char ).toString() }.sort{-it.value.size}.find{true}.key.toString()); };");
logTime('Unicodes block');

if (DISPLAY) print "String unicode done\n";

// resolving the constants
$extra_indices = array('constants', 'classes', 'interfaces', 'traits', 'functions', 'delete');
foreach($extra_indices as $indice) {
    query("g.dropIndex('$indice');");
    query("g.createManualIndex('$indice', Vertex)");
}
logTime('g.idx("last index")');

if (DISPLAY) print "Creating index for constant, function and classes resolution.\n";

$end = microtime(true);

function query($query) {
    global $client;
    $params = array('type' => 'IN');
    try {
        $GremlinQuery = new Gremlin\Query($client, $query, $params);
        return $GremlinQuery->getResultSet();
    } catch (Exception $e) {
        $fp = fopen('log/build_root.log', 'a');
        fwrite($fp, "Sleeping...\n");
        fwrite($fp, $query."\n");
        fclose($fp);
        
        print $e->getMessage();
        die('died in '.__METHOD__."\n");
    }
}

function logTime($step) {
    static $log, $begin, $end, $start;
    
    if (is_null($log)) {
        $log = fopen('log/build_root.timing.csv', 'w+');
    }
    $end = microtime(true);
    if (is_null($begin)) { 
        $begin = $end; 
        $start = $end;
    }
    
    fwrite($log, $step."\t".($end - $begin)."\t".($end - $start)."\n");
    $begin = $end;
}

?>