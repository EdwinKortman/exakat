#!/usr/bin/env php 
<?php

use Loader\Csv, Everyman\Neo4j\Client,
	Everyman\Neo4j\Index\NodeIndex,
	Everyman\Neo4j\Relationship,
	Everyman\Neo4j\Node,
	Everyman\Neo4j\Gremlin,
	Loader\Environnement,
	Loader\Neo4jphp;

include_once(dirname(__DIR__).'/library/Autoload.php');
spl_autoload_register('Autoload::autoload_library');

$log = new Log('load');

$args = $argv;

if ($id = array_search('-v', $args)) {
    define('VERBOSE', true);
} else {
    define('VERBOSE', false);
}

if ($id = array_search('-r', $args)) {
    define('RECURSIVE', true);
} else {
    define('RECURSIVE', false);
}

if ($id = array_search('-l', $args)) {
    define('LINT', true);
} else {
    define('LINT', false);
}

if ($id = array_search('-q', $args)) {
    $_PILOT = 'Loader\Csv';
} else {
    $_PILOT = 'Loader\Neo4jphp';
}

if ($id = array_search('-p', $args)) {
    $project = $args[$id + 1];
} else {
    $project = 'default';
}

if (!file_exists('./projects/'.$project.'/config.ini')) {
    print "No such project as '$project'. Aborting\n";
    die();
}

$config = parse_ini_file('./projects/'.$project.'/config.ini');
if (isset($config['phpversion'])) {
    $Php = new Phpexec($config['phpversion']);
} else {
    $Php = new Phpexec(phpversion());
}

if ($id = array_search('-f', $args)) {
    $nb_files = 0; 
    
     while (isset($args[$id + ++$nb_files]) && 
            file_exists($args[$id + $nb_files])) {
        $filename = $args[$id + $nb_files];
        print $filename."\n";
    
        $nb_tokens = process_file($filename, $log);
    }
} elseif ($id = array_search('-d', $args)) {
    $dir = $args[$id + 1];
    
    if ($dir{strlen($dir) - 1} == '/') {
        $dir = substr($dir, 0, -1);
    }
    
    $res = process_dir($dir, $log);
    $nb_files = $res['files'];
    $nb_tokens = $res['tokens'];
} else {
    print "No file to process. Aborting\n";
    die();
}

$_PILOT::finalize();
$log->report('load', array('project' => $project, 'files' => $nb_files, 'tokens' => $nb_tokens));

function process_dir($dir, $log) {
    $dirr = opendir($dir);
    $nb_files = 0;
    $nb_tokens = 0;
    while ($filename = readdir($dirr)) {
        if ($filename{0} == '.') { continue; }
        if (is_link($filename)) { continue; }
        
        if (is_dir($dir.'/'.$filename)) {
            if (RECURSIVE) {
                $res = process_dir($dir.'/'.$filename, $log);
                $nb_tokens += $res['tokens'];
                $nb_files  += $res['files'];
            }
        } else {
            if (!preg_match('/\\.('.join('|', array('php', 'php3', 'inc', 'tpl', 'phtml', 'tmpl', 'phps', 'ctp'  )).')$/', $filename)) { continue; }
            $nb_tokens += process_file($dir.'/'.$filename, $log);
            $nb_files++;
        }
    }
    return array('files' => $nb_files, 'tokens' => $nb_tokens);
}


function process_file($filename, $log_file) {
    $log = array();
    $begin = microtime(true);
    
    if (is_link($filename)) { return true; }
    if (!file_exists($filename)) {
        print "'$filename' doesn't exists. Aborting\n";
        die();
    }

    global $_PILOT, $Php;
    $client = new $_PILOT();

    $file = realpath($filename);
    if (strpos($file, '/code/') !== false) {
        $file = substr($file, strpos($file, '/code/') + 5);
    } else {
        $file = $filename;
    }
    if (filesize($filename) == 0) {
        return false;
    }

    if (!$Php->compile($filename)) {
        // @todo store line error and the actual parse error.
        $environnement = new Environnement($client, $file); 
        $environnement->initFile();
        
        print "Ignoring file $filename as it won't compile\n";
        return false;
    }
    
    $tokens = $Php->getTokenFromFile($filename);
    $log['token_initial'] = count($tokens);

    $delimitedStrings = array('T_QUOTE' => 0, 'T_SHELL_QUOTE' => 0);
    $whiteCode = $Php->getWhiteCode();
    $tokens_newlines = array();
    $merge = 0;
    $deleted = 0;
    foreach($tokens as $id => $token) {
        if ($Php->getTokenname($token[0]) == 'T_OPEN_TAG') {
            $merge = $id - $deleted + 1; // presetting the next id.
            $tokens_newlines[$merge]  = substr_count($tokens[$id][1], "\n");
        } elseif ($Php->getTokenname($token[0]) == 'T_CLOSE_TAG') {
            if (!$merge) {
                $merge = $id - count($tokens_newlines) + 1; // presetting the next id.
                $tokens_newlines[$merge]  = substr_count($tokens[$id][1], "\n");
            } else {
                $tokens_newlines[$merge] += substr_count($tokens[$id][1], "\n");
            }
        } elseif (isset($whiteCode[$token[0]])) { 
            if (!$merge) {
                $merge = $id - $deleted;
                $tokens_newlines[$merge]  = substr_count($tokens[$id][1], "\n");
            } else {
                $tokens_newlines[$merge] += substr_count($tokens[$id][1], "\n");
            }
            $x[] = substr_count($tokens[$id][1], "\n");
            $deleted++;
            unset($tokens[$id]); 
        } else {
            $merge = false;
        }
    }
    
    $tokens = array_values($tokens);

    if (count($tokens) == 2 && 
        $Php->getTokenname($tokens[0][0]) == 'T_OPEN_TAG' &&
        $Php->getTokenname($tokens[1][0]) == 'T_CLOSE_TAG') {

        $environnement = new Environnement($client, $file); 
        $environnement->initFile();

        print "Ignoring file $filename as it is empty\n";
        return false;
    }
    
    $log['token_cleaned'] = count($tokens);


    $regexIndex = array();
    $regexIndex['INDEX'] = $client->makeNode()->setProperty('token', 'INDEX')
                                              ->setProperty('code', 'Index for INDEX')
                                              ->setProperty('index', 'true')
                                              ->save();

    // @doc delete old tokens
    // This index should be only created once. It will hold all the index for files.
    $regexIndex['FILE'] = $client->makeNode()->setProperty('token', 'FILE')
                                             ->setProperty('code', 'Index for FILE')
                                             ->setProperty('index', 'true')
                                             ->save();
    $regexIndex['INDEX']->relateTo($regexIndex['FILE'], 'INDEXED');
    
    $regexIndex['CLASS'] = $client->makeNode()->setProperty('token', 'CLASS')
                                              ->setProperty('code', 'Index for CLASS')
                                              ->setProperty('index', 'true')
                                              ->save();
    $regexIndex['INDEX']->relateTo($regexIndex['CLASS'], 'INDEXED');

    $classNode = new Environnement($client, $file); 
    $classNode->init($regexIndex['CLASS']);

    $regex = Tokenizer\Token::getTokenizers(); 

    foreach($regex as $r) {
        $regexIndex[$r] = $client->makeNode()->setProperty('token', $r)
                                             ->setProperty('code', 'Index for '.$r)
                                             ->setProperty('index', 'true')
                                             ->save();
        $regexIndex['INDEX']->relateTo($regexIndex[$r], 'INDEXED');
    }

    $regexIndex['S_STRING'] = $client->makeNode()->setProperty('token', 'S_STRING')
                                                ->setProperty('code', 'Index for S_STRING')
                                                ->setProperty('index', 'true')
                                                ->save();
    $regexIndex['INDEX']->relateTo($regexIndex['S_STRING'], 'INDEXED');

    $regexIndex['S_ARRAY'] = $client->makeNode()->setProperty('token', 'S_ARRAY')
                                                ->setProperty('code', 'Index for S_ARRAY')
                                                ->setProperty('index', 'true')
                                                ->save();
    $regexIndex['INDEX']->relateTo($regexIndex['S_ARRAY'], 'INDEXED');
    
    $regexIndex['DELETE'] = $client->makeNode()->setProperty('token', 'DELETE')
                                               ->setProperty('code', 'Index for DELETE')
                                               ->setProperty('index', 'true')
                                               ->save();
    $regexIndex['INDEX']->relateTo($regexIndex['DELETE'], 'INDEXED');

    $regexIndex['ROOT'] = $client->makeNode()->setProperty('token', 'ROOT')
                                             ->setProperty('code', 'Index for ROOT')
                                             ->setProperty('index', 'true')
                                             ->save();
    $regexIndex['INDEX']->relateTo($regexIndex['ROOT'], 'INDEXED');

    // load new tokens
    $line = 0;
    
    $atoms = array( 'T_STRING'                   => 'Identifier', 
                    'T_CONSTANT_ENCAPSED_STRING' => 'String', 
                    'T_ENCAPSED_AND_WHITESPACE'  => 'String',
                    'T_INLINE_HTML'              => 'RawString',
                    'T_VARIABLE'                 => 'Variable',
                    'T_STRING_VARNAME'           => 'Variable',
                    'T_LNUMBER'                  => 'Integer', 
                    'T_NUM_STRING'               => 'Integer',
                    'T_DNUMBER'                  => 'Float', 
                    'T_CLASS_C'                  => 'Magicconstant', 
                    'T_FUNC_C'                   => 'Magicconstant', 
                    'T_DIR'                      => 'Magicconstant', 
                    'T_FILE'                     => 'Magicconstant', 
                    'T_LINE'                     => 'Magicconstant', 
                    'T_METHOD_C'                 => 'Magicconstant', 
                    'T_NS_C'                     => 'Magicconstant', 
                    'T_TRAIT_C'                  => 'Magicconstant', 
                    'T_CALLABLE'                 => 'Identifer', 
                    );
            
    
    $nb = count($tokens);
    $Tid = -1;
    $root = 0;
    $in_quote = false;
    $in_for = 0;
    $dowhiles = array();
    $block_level = 0;
    
    for($id = 0; $id < $nb; $id++) {
        if (empty($tokens[$id])) { continue; }
        $Tid++;
        $token = $tokens[$id];
        $to_index = true;

        if (is_array($token)) {
            $classNode->process($token, $Php->getTokenname($token[0]));
            if ($Php->getTokenname($token[0]) == 'T_BREAK' && is_string($tokens[$id + 1]) && $tokens[$id + 1] == ';') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenname($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2])->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $regexIndex["_Break"]->relateTo($T[$Tid], 'INDEXED')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('fullcode', ' ')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load13')
                                              ->setProperty('atom', 'Void')
                                              ->save();

                $to_index = false;
            } elseif ($Php->getTokenname($token[0]) == 'T_STATIC' && is_string($tokens[$id + 1]) && 
                      $tokens[$id + 1] != '(' && $Php->getTokenname($tokens[$id - 1][0]) == 'T_NEW') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenname($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2])->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $regexIndex["Functioncall"]->relateTo($T[$Tid], 'INDEXED')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('fullcode', ' ')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load21')
                                              ->setProperty('atom', 'Void')
                                              ->save();

                $to_index = false;
            } elseif ($Php->getTokenname($token[0]) == 'T_RETURN' && is_array($tokens[$id + 1]) && 
                      $Php->getTokenname($tokens[$id + 1][0]) == 'T_CLOSE_TAG') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenname($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2])->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $regexIndex["_Return"]->relateTo($T[$Tid], 'INDEXED')->save();
                $previous = $T[$Tid];

                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_SEMICOLON')
                                              ->setProperty('code', ';')
                                              ->setProperty('fullcode', ';')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load18')
                                              ->save();
                $regexIndex["Sequence"]->relateTo($T[$Tid], 'INDEXED')->save();

                $to_index = false;
            } elseif ($Php->getTokenname($token[0]) == 'T_OPEN_TAG' && !isset($tokens[$id + 1])) {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenname($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2])
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                if (isset($previous)) {
                    $previous->relateTo($T[$Tid], 'NEXT')->save();
                }
                $regexIndex["Phpcode"]->relateTo($T[$Tid], 'INDEXED')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_OPEN_TAG')
                                              ->setProperty('code', '<?php /* empty, no closing tag */ ?>')
                                              ->setProperty('fullcode', '<?php /* empty, no closing tag */ ?>')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Phpcode')
                                              ->setProperty('closing_tag', 'false')
                                              ->setProperty('modifiedBy', 'bin/load1')
                                              ->save();

                $to_index = false;
            } elseif ($Php->getTokenname($token[0]) == 'T_OPEN_TAG_WITH_ECHO') {
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_OPEN_TAG')
                                              ->setProperty('code', str_replace('<?=', '<?php', $token[1]))
                                              ->setProperty('tag', '<?=')
                                              ->setProperty('line', $token[2])
                                              ->setProperty('modifiedBy', 'bin/load19a')
                                              ->save();
                $classNode->relateTo($T[$Tid]);
                $regexIndex["Phpcode"]->relateTo($T[$Tid], 'INDEXED')->save();
                if (isset($previous)) {
                    $previous->relateTo($T[$Tid], 'NEXT')->save();
                }
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_ECHO')
                                              ->setProperty('code', 'echo')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load19b')
                                              ->save();
                $regexIndex["ArgumentsNoParenthesis"]->relateTo($T[$Tid], 'INDEXED')->save();
                $regexIndex["Functioncall"]->relateTo($T[$Tid], 'INDEXED')->save();

            } elseif ($Php->getTokenname($token[0]) == 'T_CLOSE_TAG' && 
                      isset($tokens[$id + 1]) && 
                      is_array($tokens[$id + 1]) && 
                      $Php->getTokenname($tokens[$id + 1][0]) == 'T_OPEN_TAG') {
                $id++;
                continue;
            } elseif ($Php->getTokenname($token[0]) == 'T_CLOSE_TAG' && 
                      isset($tokens[$id + 1]) && 
                      is_array($tokens[$id + 1]) && 
                      $Php->getTokenname($tokens[$id + 1][0]) == 'T_OPEN_TAG_WITH_ECHO') {

                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_ECHO')
                                              ->setProperty('code', 'echo')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load22')
                                              ->save();
                $regexIndex["ArgumentsNoParenthesis"]->relateTo($T[$Tid], 'INDEXED')->save();
                $regexIndex["Functioncall"]->relateTo($T[$Tid], 'INDEXED')->save();

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];

                $id++;
                continue;
            } elseif ($Php->getTokenname($token[0]) == 'T_INLINE_HTML' && 
                      $id == 0) {
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_SEMICOLON')
                                              ->setProperty('code', ';')
                                              ->setProperty('fullcode', ';')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Sequence')
                                              ->setProperty('modifiedBy', 'bin/load14')
                                              ->setProperty('root', 'true')
                                              ->save();
                $regexIndex["Sequence"]->relateTo($T[$Tid], 'INDEXED')->save();
                $classNode->relateTo($T[$Tid]);

                $inline =  $client->makeNode()->setProperty('token', $Php->getTokenname($token[0]))
                                              ->setProperty('atom', 'RawString')
                                              ->setProperty('fullcode', $token[1])
                                              ->setProperty('line', $token[2])
                                              ->setProperty('order', 0)
                                              ->setProperty('modifiedBy', 'bin/load14-2')
                                              ->setProperty('code', $token[1])
                                              ->save();
                                              ;
                $classNode->relateTo($inline);
                $T[$Tid]->relateTo($inline, 'ELEMENT')->save();
            } elseif ($Php->getTokenname($token[0])           == 'T_INLINE_HTML' && 
                      isset($tokens[$id + 1]) &&
                      $Php->getTokenname($tokens[$id + 1][0]) == 'T_INLINE_HTML') {
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_SEMICOLON')
                                              ->setProperty('code', ';')
                                              ->setProperty('fullcode', ';')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Sequence')
                                              ->setProperty('modifiedBy', 'bin/load15')
                                              ->setProperty('root', 'true')
                                              ->save();
                $regexIndex["Sequence"]->relateTo($T[$Tid], 'INDEXED')->save();
                $classNode->relateTo($T[$Tid]);

    // while ici
                $inline =  $client->makeNode()->setProperty('token', $Php->getTokenname($token[0]))
                                              ->setProperty('atom', 'RawString')
                                              ->setProperty('fullcode', $token[1])
                                              ->setProperty('line', $token[2])
                                              ->setProperty('order', 0)
                                              ->setProperty('modifiedBy', 'bin/load15-2')
                                              ->setProperty('code', $token[1])
                                              ->save();
                                              ;
                $classNode->relateTo($inline);
                $T[$Tid]->relateTo($inline, 'ELEMENT')->save();
            } else {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenname($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2]);
            }

            // do.. while special
            if ($Php->getTokenname($token[0]) == 'T_DO') {
                $dowhiles[] = array('node' => $T[$Tid], 'level' => $block_level);
            } elseif ($Php->getTokenname($token[0]) == 'T_WHILE') {
                if (empty($dowhiles)) {
                    $T[$Tid]->setProperty('dowhile', 'false')->save();
                } else {
                    if ($block_level == $dowhiles[count($dowhiles) - 1]['level']) {
                        $T[$Tid]->setProperty('dowhile', 'true')->save();
                        array_pop($dowhiles);
                    } else {
                        $T[$Tid]->setProperty('dowhile', 'false')->save();
                    }
                }
            }

            $x = $T[$Tid]->getProperty('code');
            // guessing binary code : one may also use 4, 8 or any chr that is supposed to be non ascii. 
            if (strpos($x, chr(2)) !== false) { 
                $T[$Tid]->setProperty('code', "Binary data <length ".strlen($x)." bytes>");
            }

            $T[$Tid]->save();
            $classNode->relateTo($T[$Tid]);
            
            if ($Php->getTokenname($token[0]) == 'T_STRING' && (strtolower($token[1]) == 'true' || strtolower($token[1]) == 'false')) {
                $T[$Tid]->setProperty('atom', 'Boolean')
                        ->setProperty('code', $token[1])
                        ->setProperty('fullcode', $token[1])->save();
                $to_index = ($tokens[$id + 1] == '('); // if the next is (, this may be a function or a method!!
            } elseif (isset($atoms[$Php->getTokenname($token[0])])) {
                if ($Php->getTokenname($token[0]) == 'T_STRING') {
                    $T[$Tid]->setProperty('atom', $atoms[$Php->getTokenname($token[0])])
                            ->setProperty('code', $token[1])
                            ->setProperty('fullcode', $token[1])->save();
                    $regexIndex['S_STRING']->relateTo($T[$Tid], 'INDEXED');

                } elseif ($Php->getTokenname($token[0]) == 'T_STRING_VARNAME') {
                    $T[$Tid]->setProperty('atom', $atoms[$Php->getTokenname($token[0])])
                            ->setProperty('code', '$'.$token[1])
                            ->setProperty('fullcode', '$'.$token[1])->save();
                } elseif ($Php->getTokenname($token[0]) == 'T_INLINE_HTML' && $id == 0) {
                    // ignore
                } elseif ($Php->getTokenname($token[0]) == 'T_INLINE_HTML' &&
                          isset($tokens[$id + 1]) &&
                          $Php->getTokenname($tokens[$id + 1][0]) == 'T_INLINE_HTML') {
                    // ignore
                } elseif ($Php->getTokenname($token[0]) == 'T_CONSTANT_ENCAPSED_STRING') {
                    $T[$Tid]->setProperty('delimiter', in_array($token[1][0], array("'", '"')) ? $token[1][0] : '')
                            ->setProperty('noDelimiter', trim($token[1], '"\''))
                            ->setProperty('atom', $atoms[$Php->getTokenname($token[0])])
                            ->setProperty('code', $token[1])
                            ->setProperty('fullcode', $token[1])->save();

                    $regexIndex['S_STRING']->relateTo($T[$Tid], 'INDEXED');
                } else {
                    $T[$Tid]->setProperty('atom', $atoms[$Php->getTokenname($token[0])])
                            ->setProperty('modifiedBy', 'bin/load17')
                            ->setProperty('code', $token[1])
                            ->setProperty('fullcode', $token[1])->save();
                    if ($Php->getTokenname($token[0]) == 'T_ENCAPSED_AND_WHITESPACE') {
                        $regexIndex['S_STRING']->relateTo($T[$Tid], 'INDEXED');
                    }
                }
            }

            $token_value = $Php->getTokenname($token[0]);
            if ($token_value == 'T_CURLY_OPEN' || $token_value == 'T_DOLLAR_OPEN_CURLY_BRACES') {
                $block_level++;
            }

            if ($token_value == 'T_OPEN_CURLY') {
                $token_value = 'T_CURLY_OPEN';
            }

            $line = $token[2];
        } else {
/// case of the token that is not an array

            if (isset($tokens_newlines[$id])) {
                $line += $tokens_newlines[$id];
                unset($tokens_newlines[$id]);
            } 

            $token_value = $Php->getTokenname($token);
            $classNode->process($token, $token_value);
            
            if ($token_value == 'T_OPEN_CURLY') {
                $block_level ++;
            } elseif ($token_value == 'T_CLOSE_CURLY') {
                $block_level --;
            }
            
            if (in_array($token_value, array('T_QUOTE', 'T_SHELL_QUOTE'))) {
                $delimitedStrings[$token_value]++;
                if ($delimitedStrings[$token_value] % 2 == 0) {
                    $token .= '_CLOSE';
                    $token_value .= '_CLOSE';
                }
            }
            
            if ($token == '{' && $tokens[$id + 1] == '}') {
                $block_level--;
                if ( $tokens[$id - 1] == ')' || (is_array($tokens[$id - 1]) && in_array($Php->getTokenName($tokens[$id - 1][0]), array('T_STRING', 'T_NAMESPACE', 'T_TRY')))) {
                    $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                                  ->setProperty('code', $token)
                                                  ->setProperty('fullcode', '{ /**/ } ')
                                                  ->setProperty('line', $line)
                                                  ->setProperty('atom', 'Sequence')
                                                  ->setProperty('order', '0')
                                                  ->setProperty('block', 'true')
                                                  ->setProperty('modifiedBy', 'bin/load12a')
                                                  ->save();
                    $classNode->relateTo($T[$Tid]);

                    $void   = $client->makeNode()->setProperty('token', 'T_VOID')
                                                 ->setProperty('code', 'void')
                                                 ->setProperty('fullcode', ' ')
                                                 ->setProperty('line', $line)
                                                 ->setProperty('atom', 'Void')
                                                 ->setProperty('modifiedBy', 'bin/load3')
                                                 ->setProperty('order', 0)
                                                 ->save();
                    $classNode->relateTo($void);

                    $T[$Tid]->relateTo($void, 'ELEMENT')->save();
                } else {
                    $block = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                                  ->setProperty('code', $token)
                                                  ->setProperty('fullcode', '{ /**/ } ')
                                                  ->setProperty('line', $line)
                                                  ->setProperty('atom', 'Sequence')
                                                  ->setProperty('order', 0)
                                                  ->setProperty('block', 'true')
                                                  ->setProperty('modifiedBy', 'bin/load12b')
                                                  ->save();
                    $classNode->relateTo($block);

                    $void   = $client->makeNode()->setProperty('token', 'T_VOID')
                                                 ->setProperty('code', 'void')
                                                 ->setProperty('fullcode', ' ')
                                                 ->setProperty('line', $line)
                                                 ->setProperty('atom', 'Void')
                                                 ->setProperty('modifiedBy', 'bin/load3')
                                                 ->setProperty('order', 0)
                                                 ->save();
                    $classNode->relateTo($void);

                    $T[$Tid] = $client->makeNode()->setProperty('token', 'T_SEMICOLON')
                                                 ->setProperty('code', ';')
                                                 ->setProperty('fullcode', ';')
                                                 ->setProperty('line', $line)
                                                 ->setProperty('atom', 'Sequence')
                                                 ->setProperty('modifiedBy', 'bin/load3')
                                                 ->save();
                    $T[$Tid]->relateTo($block, 'ELEMENT')->save();
                    $regexIndex["Sequence"]->relateTo($T[$Tid], 'INDEXED')->save();                

                    $block->relateTo($void, 'ELEMENT')->save();
                }
                
                $classNode->process($tokens[$id + 1], $Php->getTokenName($tokens[$id + 1]));
                unset($tokens[$id + 1]);
                
                $to_index = false;
            } elseif ($token == ':' 
                      && isset($tokens[$id + 1]) && is_string($tokens[$id + 1])  
                      && $tokens[$id + 1] == ';'
                      && isset($tokens[$id + 2]) && is_array($tokens[$id + 2])  
                      && in_array($Php->getTokenname($tokens[$id + 2][0]), array('T_ELSE', 'T_ELSEIF', 'T_ENDIF', 'T_ENDFOR', 'T_ENDFOREACH', 'T_ENDWHILE', 'T_ENDDECLARE'))) {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                if ($type = process_colon($token_value)) {
                    $T[$Tid]->setProperty('association', $type)->save();
                }
                $classNode->relateTo($T[$Tid]);
                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];

                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('fullcode', ' ')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Void')
                                              ->setProperty('modifiedBy', 'bin/load5')
                                              ->save();
                $classNode->relateTo($T[$Tid]);
                $to_index = false;
            } elseif ($token == '(' && $tokens[$id + 1] == ')' &&
                      $Php->getTokenname($tokens[$id - 1][0]) != 'T_HALT_COMPILER') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);
                $regexIndex["Parenthesis"]->relateTo($T[$Tid], 'INDEXED')->save();                
                $regexIndex["ArgumentsNoComma"]->relateTo($T[$Tid], 'INDEXED')->save();                
                $regexIndex["Typehint"]->relateTo($T[$Tid], 'INDEXED')->save();                
                $regexIndex["ArgumentsArray"]->relateTo($T[$Tid], 'INDEXED')->save();                

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('fullcode', ' ')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Void')
                                              ->setProperty('modifiedBy', 'bin/load6')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ( ($tokens[$id] == '(' || $tokens[$id] == ';') && 
                            isset($tokens[$id + 1]) && is_string($tokens[$id + 1]) &&
                            ( $tokens[$id + 1] == ';' || $tokens[$id + 1] == ')')) {
                    // This must be after the processing of ( and ) (right above)
                    $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                                  ->setProperty('code', $token)
                                                  ->setProperty('line', $line)
                                                  ->setProperty('modifiedBy', 'bin/load18a')
                                                  ->save();
                    $classNode->relateTo($T[$Tid]);

                    $regexIndex["Sequence"]->relateTo($T[$Tid], 'INDEXED')->save();
                    $previous->relateTo($T[$Tid], 'NEXT')->save();
                    $previous = $T[$Tid];
                
                    $Tid++;
                    $T[$Tid]   = $client->makeNode()->setProperty('token', 'T_VOID')
                                                    ->setProperty('code', 'void')
                                                    ->setProperty('fullcode', ' ')
                                                    ->setProperty('line', $line)
                                                    ->setProperty('atom', 'Void')
                                                    ->setProperty('modifiedBy', 'bin/load8b')
                                                    ->save();
                    $classNode->relateTo($T[$Tid]);
                    $to_index = false;
                } elseif ($token == ':' && isset($tokens[$id + 1]) && is_array($tokens[$id + 1])  
                      && in_array($Php->getTokenname($tokens[$id + 1][0]), array('T_ELSE', 'T_ELSEIF', 'T_ENDIF', 'T_ENDFOR', 'T_ENDFOREACH', 'T_ENDWHILE', 'T_ENDDECLARE'))) {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                if ($type = process_colon($token_value)) {
                    $T[$Tid]->setProperty('association', $type)->save();
                }
                $classNode->relateTo($T[$Tid]);
                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];

                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('fullcode', ' ')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Void')
                                              ->setProperty('modifiedBy', 'bin/load4')
                                              ->save();
                $classNode->relateTo($T[$Tid]);
            } elseif ($token == '{' && $tokens[$id + 1] == ';') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];
                $regexIndex["Block"]->relateTo($T[$Tid], 'INDEXED')->save();                
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('fullcode', ' ')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Void')
                                              ->setProperty('modifiedBy', 'bin/load7')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ($token == '(' && $tokens[$id + 1] == ',') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('fullcode', ' ')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load8')
                                              ->setProperty('atom', 'Void')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ($token == ',' && $tokens[$id + 1] == ')') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $regexIndex["Arguments"]->relateTo($T[$Tid], 'INDEXED')->save();              
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('fullcode', ' ')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load9')
                                              ->setProperty('atom', 'Void')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ($token == ',' && $tokens[$id + 1] == ',') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $regexIndex["Arguments"]->relateTo($T[$Tid], 'INDEXED')->save();              
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('fullcode', ' ')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load10')
                                              ->setProperty('atom', 'Void')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ($token == '{' && $tokens[$id + 1] == ';' && $tokens[$id + 2] == '}' ) {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Block')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $void   = $client->makeNode()->setProperty('token', 'T_VOID')
                                             ->setProperty('code', 'void')
                                             ->setProperty('fullcode', ' ')
                                             ->setProperty('line', $line)
                                             ->setProperty('modifiedBy', 'bin/load11')
                                             ->setProperty('atom', 'Void')
                                             ->setProperty('order', 0)
                                             ->save();
                $classNode->relateTo($void);

                $sequence = $client->makeNode()->setProperty('token', 'T_SEMICOLON')
                                               ->setProperty('code', ';')
                                               ->setProperty('fullcode', ';')
                                               ->setProperty('line', $line)
                                               ->setProperty('atom', 'Sequence')
                                               ->setProperty('order', 0)
                                               ->save();
                $classNode->relateTo($T[$Tid]);

                $T[$Tid]->relateTo($sequence, 'ELEMENT')->save();
                $sequence->relateTo($void, 'ELEMENT')->save();

                unset($tokens[$id + 1]);
                $classNode->process($tokens[$id + 1], $Php->getTokenName($tokens[$id + 1]));
                unset($tokens[$id + 2]);
                $classNode->process($tokens[$id + 2], $Php->getTokenName($tokens[$id + 2]));
                $to_index = false;
            } else {
                $T[$Tid] = $client->makeNode()->setProperty('token', $Php->getTokenName($token))
                                              ->setProperty('code', $token) // no fullcode at this level!
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);
            }
    
            $T[$Tid]->save();
        }

        if (in_array($token_value, array('T_QUOTE', 'T_SHELL_QUOTE', 'T_START_HEREDOC'))) {
            $in_quote = true;
            if (is_array($token)) {
                $T[$Tid]->setProperty('fullcode', $token[1])->save();
            } else {
                $T[$Tid]->setProperty('fullcode', $token)->save();
            }
        } elseif (in_array($token_value, array('T_QUOTE_CLOSE', 'T_SHELL_QUOTE_CLOSE', 'T_END_HEREDOC'))) {
            $in_quote = false;
            $T[$Tid]->setProperty('in_quote', "'true'")->save();
            if (is_array($token)) {
                $T[$Tid]->setProperty('fullcode', $token[1])->save();
            } else {
                $T[$Tid]->setProperty('fullcode', $token)->save();
            }
        }

        if ($in_quote) {
            $T[$Tid]->setProperty('in_quote', "'true'")->save();
        } 

        if (in_array($token_value, array('T_FOR'))) {
            $in_for = 1;
        }

        if ($in_for > 0) {
            if (in_array($token_value, array('T_OPEN_PARENTHESIS'))) {
                $in_for++;
            } elseif (in_array($token_value, array('T_CLOSE_PARENTHESIS'))) {
                $in_for--;
                if ($in_for == 1) {
                    $in_for = 0;
                }
            } 
        }

        if ($in_for > 1) {
            $T[$Tid]->setProperty('in_for', "'true'")->save();
        } 
        
        if ($type = process_colon($token_value)) {
            $T[$Tid]->setProperty('association', $type)->save();
        }

        // test is for booleans. 
        if ($to_index) {
            $regex = Tokenizer\Token::getTokenizers(); 
            foreach($regex as $r) {
                $class = "Tokenizer\\$r";
                if (in_array($token_value, $class::$operators)) { 
                    $regexIndex[$r]->relateTo($T[$Tid], 'INDEXED')->save();
                }
            }
        }
        
        if (!isset($previous)) {
            $previous = $T[$Tid];
        } else {
            $previous->relateTo($T[$Tid], 'NEXT')->save();
            $previous = $T[$Tid];
            
            // Saving on memory, we don't keep the previous ones.
            if ($Tid > 1) {
                unset($T[$Tid - 1]);
            }
        }
    }

    $end = microtime(true);
    $log['memory_usage'] = memory_get_usage(true);
    $log['memory_max_usage'] = memory_get_peak_usage(true);
    $log_file->log("$filename\t".(($end - $begin)*1000)."\t".join("\t", $log));

    if (!isset($T)) { 
        print "Empty script. Ignoring\n";    
        return false;
    }
    $T[0]->setProperty('root', 'true')->save();
    
    $T[-1] = $client->makeNode()->setProperty('token', 'T_ROOT')
                                ->setProperty('code', '/**/')
                                ->setProperty('hidden', true)
                                ->save();
    $regexIndex['ROOT']->relateTo($T[-1], 'INDEXED')->save();

    $fileNode = $client->makeNode()->setProperty('token', 'T_FILENAME')
                                   ->setProperty('atom', "File")
                                   ->setProperty('filename', preg_replace('#^\./projects/[^/]+/code/#', '/', $filename))
                                   ->setProperty('code', "$filename")
                                   ->setProperty('fullcode', "$filename")
                                   ->save();
    $fileNode->relateTo($T[0], 'FILE')->save();

    $classNode->relateTo($T[-1]);
    
    $last     = $client->makeNode()->setProperty('token', 'T_END')
                                   ->setProperty('code', '/**/')
                                   ->setProperty('line', $line)
                                   ->setProperty('hidden', true)
                                   ->save();

    $T[-1]->relateTo($T[0], 'NEXT')->setProperty('file', $file)->save();
    $previous->relateTo($last, 'NEXT')->setProperty('file', $file)->save();
    $classNode->relateTo($last);
    
    $last2     = $client->makeNode()->setProperty('token', 'T_END')
                                    ->setProperty('code', '/* * */')
                                    ->setProperty('line', $line)
                                    ->setProperty('hidden', true)
                                    ->save();

    $last->relateTo($last2, 'NEXT')->setProperty('file', $file)->save();
    $classNode->relateTo($last2);

    $client->save_chunk();
    
    return $Tid;
}

function process_colon($token_value) {
    static $states = array();
    static $states_id = 0;
    
    if ($token_value == "T_QUESTION" ) { $states[] = 'Ternary'; $states_id++; return ''; }

    if ($token_value == "T_SWITCH" )   { $states[] = 'Switch';  $states_id++; return ''; }
    if ($token_value == "T_CASE" )     { $states[] = 'Case';    $states_id++; return ''; }
    if ($token_value == "T_DEFAULT" )  { $states[] = 'Default'; $states_id++; return ''; }

    if ($token_value == "T_FOR" )      { $states[] = 'For';     $states_id++; return ''; }
    if ($token_value == "T_FOREACH" )  { $states[] = 'Foreach'; $states_id++; return ''; }
    if ($token_value == "T_WHILE" )    { $states[] = 'While';   $states_id++; return ''; }

    if ($token_value == "T_COLON" )    { $state = array_pop($states);  return $state; }
    
    return '';
}

function query($query, $client) {
    $params = array('type' => 'IN');
    try {
        $GremlinQuery = new Gremlin\Query($client, $query, $params);
        return $GremlinQuery->getResultSet();
    } catch (Exception $e) {
        $fp = fopen('log/build_root.log', 'a');
        fwrite($fp, "Sleeping...\n");
        fwrite($fp, $query."\n");
        fclose($fp);
        
        sleep(2);
        query($query);
    }
}

?>