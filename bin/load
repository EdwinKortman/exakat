#!/usr/bin/env php 
<?php

use Loader\Csv, Everyman\Neo4j\Client,
	Everyman\Neo4j\Index\NodeIndex,
	Everyman\Neo4j\Relationship,
	Everyman\Neo4j\Node,
	Everyman\Neo4j\Gremlin,
	Loader\Environnement,
	Loader\Neo4jphp;

include_once(dirname(__DIR__).'/library/Autoload.php');
spl_autoload_register('Autoload::autoload_library');

$log = new Log('load');

$args = $argv;

if ($id = array_search('-v', $args)) {
    define('VERBOSE', true);
} else {
    define('VERBOSE', false);
}

if ($id = array_search('-r', $args)) {
    define('RECURSIVE', true);
} else {
    define('RECURSIVE', false);
}

if ($id = array_search('-l', $args)) {
    define('LINT', true);
} else {
    define('LINT', false);
}

if ($id = array_search('-q', $args)) {
    $_PILOT = 'Loader\Csv';
} else {
    $_PILOT = 'Loader\Neo4jphp';
}

if ($id = array_search('-p', $args)) {
    $project = $args[$id + 1];
} else {
    $project = 'default';
}

if ($id = array_search('-f', $args)) {
    $filename = $args[$id + 1];
    
    $nb_tokens = process_file($filename, $log);
    $nb_files = 1;
} elseif ($id = array_search('-d', $args)) {
    $dir = $args[$id + 1];
    
    if ($dir{strlen($dir) - 1} == '/') {
        $dir = substr($dir, 0, -1);
    }
    
    $res = process_dir($dir, $log);
    $nb_files = $res['files'];
    $nb_tokens = $res['tokens'];
} else {
    print "No file to process. Aborting\n";
    die();
}

$_PILOT::finalize();
$log->report('load', array('project' => $project, 'files' => $nb_files, 'tokens' => $nb_tokens));

function process_dir($dir, $log) {
    $dirr = opendir($dir);
    $nb_files = 0;
    $nb_tokens = 0;
    while ($filename = readdir($dirr)) {
        if ($filename{0} == '.') { continue; }
        if (is_link($filename)) { continue; }
        
        if (is_dir($dir.'/'.$filename)) {
            if (RECURSIVE) {
                $res = process_dir($dir.'/'.$filename, $log);
                $nb_tokens += $res['tokens'];
                $nb_files  += $res['files'];
            }
        } else {
            if (substr($filename, -4) != '.php') { continue; }
            $nb_tokens += process_file($dir.'/'.$filename, $log);
            $nb_files++;
        }
    }
    return array('files' => $nb_files, 'tokens' => $nb_tokens);
}


function process_file($filename, $log_file) {
    $log = array();
    $begin = microtime(true);
    
    if (is_link($filename)) { return true; }
    if (!file_exists($filename)) {
        print "'$filename' doesn't exists. Aborting\n";
        die();
    }

    global $_PILOT;
    $client = new $_PILOT();

    $file = realpath($filename);

        $shell = shell_exec('php -l '.$filename.' 2>&1');
        if (trim($shell) != 'No syntax errors detected in '.$filename) {
            $environnement = new Environnement($client, $file); 
            $environnement->initFile();
            
            print "Ignoring file $filename as it won't compile\n";
            return false;
        }
    
    if (filesize($filename) == 0) {
        return false;
    }
    
    shell_exec('php -r "print \'<?php \\$tokens = \'; var_export(token_get_all(file_get_contents(\''.$filename.'\'))); print \'; ?>\';" > tokens.php');
    include('tokens.php');

    $log['token_initial'] = count($tokens);
    

    // @doc delete old tokens
    // This index should be only created once. It will hold all the index for files.
    $regexIndex['FILE'] = $client->makeNode()->setProperty('token', 'FILE')
                                             ->setProperty('code', 'Index for FILE')
                                             ->setProperty('index', 'true')
                                             ->save();
    $regexIndex['CLASS'] = $client->makeNode()->setProperty('token', 'CLASS')
                                              ->setProperty('code', 'Index for CLASS')
                                              ->setProperty('index', 'true')
                                              ->save();

    $classNode = new Environnement($client, $file); 
    $classNode->init($regexIndex['CLASS']);

    $regex = Tokenizer\Token::$types; 
    $regexIndex = array();
    foreach($regex as $r) {
        $regexIndex[$r] = $client->makeNode()->setProperty('token', $r)
                                             ->setProperty('code', 'Index for '.$r)
                                             ->setProperty('index', 'true')
                                             ->save();
    }

    $regexIndex['S_ARRAY'] = $client->makeNode()->setProperty('token', 'S_ARRAY')
                                                ->setProperty('code', 'Index for S_ARRAY')
                                                ->setProperty('index', 'true')
                                                ->save();
    
    $regexIndex['DELETE'] = $client->makeNode()->setProperty('token', 'DELETE')
                                               ->setProperty('code', 'Index for DELETE')
                                               ->setProperty('index', 'true')
                                               ->save();

    $regexIndex['ROOT'] = $client->makeNode()->setProperty('token', 'ROOT')
                                             ->setProperty('code', 'Index for ROOT')
                                             ->setProperty('index', 'true')
                                             ->save();

    // load new tokens
    $line = 0;
    $TPHP = array(";" => 'T_SEMICOLON',
                  "=" => 'T_EQUAL',
                  "+" => 'T_PLUS',
                  "-" => 'T_MINUS',
                  "*" => 'T_STAR',
                  "/" => 'T_SLASH',
                  "%" => 'T_PERCENTAGE',
                  "(" => 'T_OPEN_PARENTHESIS',
                  ")" => 'T_CLOSE_PARENTHESIS',
                  "!" => 'T_BANG',
                  "[" => 'T_OPEN_BRACKET',
                  "]" => 'T_CLOSE_BRACKET',
                  "{" => 'T_OPEN_CURLY',
                  "}" => 'T_CLOSE_CURLY',
                  '.' => 'T_DOT',
                  ',' => 'T_COMMA',
                  '@' => 'T_AT',
                  '?' => 'T_QUESTION',
                  ':' => 'T_COLON',
                  '>' => 'T_GREATER',
                  '<' => 'T_SMALLER',
                  '&' => 'T_AND',
                  '^' => 'T_OR',
                  '|' => 'T_XOR',
                  '&&' => 'T_ANDAND',
                  '||' => 'T_OROR',
                  '"' => 'T_QUOTE',
                  '"_CLOSE' => 'T_QUOTE_CLOSE',
                  '$' => 'T_DOLLAR',
                  '`' => 'T_SHELL_QUOTE',
                  '`_CLOSE' => 'T_SHELL_QUOTE_CLOSE',
                  '~' => 'T_TILDE',
                  );
    
    $atoms = array( 'T_STRING'                   => 'Identifier', 
                    'T_CONSTANT_ENCAPSED_STRING' => 'String', 
                    'T_ENCAPSED_AND_WHITESPACE'  => 'String',
                    'T_INLINE_HTML'              => 'RawString',
                    'T_VARIABLE'                 => 'Variable',
                    'T_STRING_VARNAME'           => 'Variable',
                    'T_LNUMBER'                  => 'Integer', 
                    'T_NUM_STRING'               => 'Integer',
                    'T_DNUMBER'                  => 'Float', 
                    'T_CLASS_C'                  => 'Magicconstant', 
                    'T_FUNC_C'                   => 'Magicconstant', 
                    'T_DIR'                      => 'Magicconstant', 
                    'T_FILE'                     => 'Magicconstant', 
                    'T_LINE'                     => 'Magicconstant', 
                    'T_METHOD_C'                 => 'Magicconstant', 
                    'T_NS_C'                     => 'Magicconstant', 
                    );
            
    
    $count = array();
    foreach($tokens as $id => $token) {
        if ($token[0] == T_WHITESPACE)  { unset($tokens[$id]); }
        if ($token[0] == T_COMMENT)     { unset($tokens[$id]); }
        if ($token[0] == T_DOC_COMMENT) { unset($tokens[$id]); }
    }
    $tokens = array_values($tokens);
    $log['token_cleaned'] = count($tokens);
    
    $nb = count($tokens);
    $Tid = -1;
    $root = 0;
    $in_quote = false;
    for($id = 0; $id < $nb; $id++) {
        if (empty($tokens[$id])) { 
            continue; 
        }
        $Tid++;
        $token = $tokens[$id];
        $to_index = true;
        
        $classNode->process($token);
        if (is_array($token)) {
            if (token_name($token[0]) == 'T_BREAK' && is_string($tokens[$id + 1]) && $tokens[$id + 1] == ';') {
                $T[$Tid] = $client->makeNode()->setProperty('token', token_name($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2])->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $regexIndex["_Break"]->relateTo($T[$Tid], 'INDEXED')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load13')
                                              ->setProperty('atom', 'Void')
                                              ->save();

                $to_index = false;
            } elseif (token_name($token[0]) == 'T_OPEN_TAG' && !isset($tokens[$id + 1])) {
                $T[$Tid] = $client->makeNode()->setProperty('token', token_name($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2])
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                if (isset($previous)) {
                    $previous->relateTo($T[$Tid], 'NEXT')->save();
                }
                $regexIndex["Phpcode"]->relateTo($T[$Tid], 'INDEXED')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Void')
                                              ->setProperty('modifiedBy', 'bin/load1')
                                              ->save();

                $to_index = false;
            } elseif (token_name($token[0]) == 'T_OPEN_TAG_WITH_ECHO') {
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_OPEN_TAG')
                                              ->setProperty('code', str_replace('<?=', '<?php', $token[1]))
                                              ->setProperty('line', $token[2])
                                              ->save();
                $classNode->relateTo($T[$Tid]);
                $regexIndex["Phpcode"]->relateTo($T[$Tid], 'INDEXED')->save();
                if (isset($previous)) {
                    $previous->relateTo($T[$Tid], 'NEXT')->save();
                }
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_ECHO')
                                              ->setProperty('code', 'echo')
                                              ->setProperty('line', $line)
                                              ->save();
                $regexIndex["ArgumentsNoParenthesis"]->relateTo($T[$Tid], 'INDEXED')->save();
                $regexIndex["Functioncall"]->relateTo($T[$Tid], 'INDEXED')->save();

            } elseif (token_name($token[0]) == 'T_CLOSE_TAG' && isset($tokens[$id + 1]) && is_array($tokens[$id + 1])  && token_name($tokens[$id + 1][0]) == 'T_OPEN_TAG') {
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Void')
                                              ->setProperty('modifiedBy', 'bin/load2')
                                              ->save();

                $id++;
            } else {
                $T[$Tid] = $client->makeNode()->setProperty('token', token_name($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2]);
            }

            $x = $T[$Tid]->getProperty('code');
            // one may also use 4, 8 or any chr that is supposed to be non ascii. 
            if (strpos($x, chr(2)) !== false) { 
                $T[$Tid]->setProperty('code', "Binary data <length ".strlen($x)." bytes>");
            }

            $T[$Tid]->save();
            $classNode->relateTo($T[$Tid]);
            
            if (token_name($token[0]) == 'T_STRING' && (strtolower($token[1]) == 'true' || strtolower($token[1]) == 'false')) {
                $T[$Tid]->setProperty('atom', 'Boolean')->save();
                $to_index = false;
            } elseif (isset($atoms[token_name($token[0])])) {
                if (token_name($token[0]) == 'T_STRING') {
                    $T[$Tid]->setProperty('atom', $atoms[token_name($token[0])])->save();
                } else {
                    $T[$Tid]->setProperty('atom', $atoms[token_name($token[0])])->save();
                }
            }

            $token_value = token_name($token[0]);
            if ($token_value == 'T_OPEN_CURLY') {
                $token_value = 'T_CURLY_OPEN';
            }

            $line = $token[2];
        } else {
            if (!isset($TPHP[$token])) {
                print("No TPHP for '{$token}'\n");
                $TPHP[$token] = max($TPHP) + 1;
            }

            $token_value = $TPHP[$token];
            if (in_array($TPHP[$token], array('T_QUOTE', 'T_SHELL_QUOTE'))) {
                @$count[$TPHP[$token]]++;
                if ($count[$TPHP[$token]] % 2 == 0) {
                    $token .= '_CLOSE';
                    $token_value .= '_CLOSE';
                }
            }
            
            if ($token == '{' && $tokens[$id + 1] == '}') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Block')
                                              ->setProperty('modifiedBy', 'bin/load12')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $void   = $client->makeNode()->setProperty('token', 'T_VOID')
                                             ->setProperty('code', 'void')
                                             ->setProperty('line', $line)
                                             ->setProperty('atom', 'Void')
                                             ->setProperty('modifiedBy', 'bin/load3')
                                             ->save();
                $classNode->relateTo($void);

                $T[$Tid]->relateTo($void, 'CODE')->save();

                $classNode->process($tokens[$id + 1]);
                unset($tokens[$id + 1]);
                $to_index = false;
            } elseif ($token == ':' && isset($tokens[$id + 1]) && is_array($tokens[$id + 1])  
                      && in_array(token_name($tokens[$id + 1][0]), array('T_ELSE', 'T_ELSEIF', 'T_ENDIF', 'T_ENDFOR', 'T_ENDFOREACH', 'T_ENDWHILE', 'T_ENDDECLARE'))) {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);
                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];

                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Void')
                                              ->setProperty('modifiedBy', 'bin/load4')
                                              ->save();
                $classNode->relateTo($T[$Tid]);
            } elseif ($token == ':' 
                      && isset($tokens[$id + 1]) && is_string($tokens[$id + 1])  
                      && $tokens[$id + 1] == ';'
                      && isset($tokens[$id + 2]) && is_array($tokens[$id + 2])  
                      && in_array(token_name($tokens[$id + 2][0]), array('T_ELSE', 'T_ELSEIF', 'T_ENDIF', 'T_ENDFOR', 'T_ENDFOREACH', 'T_ENDWHILE', 'T_ENDDECLARE'))) {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);
                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];

                $Tid++;
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Void')
                                              ->setProperty('modifiedBy', 'bin/load5')
                                              ->save();
                $classNode->relateTo($T[$Tid]);
            } elseif ($token == '(' && $tokens[$id + 1] == ')') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Arguments')
                                             ->setProperty('modifiedBy', 'bin/load6')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ($token == '{' && $tokens[$id + 1] == ';') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];
                $regexIndex["Block"]->relateTo($T[$Tid], 'INDEXED')->save();                
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Void')
                                              ->setProperty('modifiedBy', 'bin/load7')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ($token == '(' && $tokens[$id + 1] == ',') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load8')
                                              ->setProperty('atom', 'Void')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ($token == ',' && $tokens[$id + 1] == ')') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $regexIndex["Arguments"]->relateTo($T[$Tid], 'INDEXED')->save();              
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load9')
                                              ->setProperty('atom', 'Void')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ($token == ',' && $tokens[$id + 1] == ',') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $regexIndex["Arguments"]->relateTo($T[$Tid], 'INDEXED')->save();              
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('modifiedBy', 'bin/load10')
                                              ->setProperty('atom', 'Void')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $to_index = false;
            } elseif ($token == '{' && $tokens[$id + 1] == ';' && $tokens[$id + 2] == '}' ) {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->setProperty('atom', 'Block')
                                              ->save();
                $classNode->relateTo($T[$Tid]);

                $void   = $client->makeNode()->setProperty('token', 'T_VOID')
                                             ->setProperty('code', 'void')
                                             ->setProperty('line', $line)
                                             ->setProperty('modifiedBy', 'bin/load11')
                                             ->setProperty('atom', 'Void')
                                             ->save();
                $classNode->relateTo($void);

                $sequence = $client->makeNode()->setProperty('token', 'T_SEMICOLON')
                                               ->setProperty('code', ';')
                                               ->setProperty('line', $line)
                                               ->setProperty('atom', 'Sequence')
                                               ->save();
                $classNode->relateTo($T[$Tid]);

                $T[$Tid]->relateTo($sequence, 'CODE')->save();
                $sequence->relateTo($void, 'CODE')->save();

                unset($tokens[$id + 1]);
                $classNode->process($tokens[$id + 1]);
                unset($tokens[$id + 2]);
                $classNode->process($tokens[$id + 2]);
                $to_index = false;
            } else {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->save();
                $classNode->relateTo($T[$Tid]);
            }
    
            $T[$Tid]->save();
        }

        if (in_array($token_value, array('T_QUOTE', 'T_SHELL_QUOTE', 'T_START_HEREDOC'))) {
            $in_quote = true;
        } elseif (in_array($token_value, array('T_QUOTE_CLOSE', 'T_SHELL_QUOTE_CLOSE', 'T_END_HEREDOC'))) {
            $in_quote = false;
            $T[$Tid]->setProperty('in_quote', 'true')->save();
        }
        
        if ($in_quote) {
            $T[$Tid]->setProperty('in_quote', 'true')->save();
        }

        // test is for booleans. 
        if ($to_index) {
            $regex = Tokenizer\Token::$types; 
            foreach($regex as $r) {
                $class = "Tokenizer\\$r";
                if (in_array($token_value, $class::$operators)) { 
                    $regexIndex[$r]->relateTo($T[$Tid], 'INDEXED')->save();
                }
            }
        }
        
        if (!isset($previous)) {
            $previous = $T[$Tid];
        } else {
            $previous->relateTo($T[$Tid], 'NEXT')->save();
            $previous = $T[$Tid];
            
            // Saving on memory, we don't keep the previous ones.
            if ($Tid > 1) {
                unset($T[$Tid - 1]);
            }
        }
    }

    $end = microtime(true);
    $log['memory_usage'] = memory_get_usage(true);
    $log['memory_max_usage'] = memory_get_peak_usage(true);
    $log_file->log("$filename\t".(($end - $begin)*1000)."\t".join("\t", $log));

    if (!isset($T)) { 
        print "Empty script. Ignoring\n";    
        return false;
    }
    $T[0]->setProperty('root', 'true')->save();
    
    $T[-1] = $client->makeNode()->setProperty('token', 'T_ROOT')
                                ->setProperty('code', '/**/')
                                ->setProperty('line', 0)
                                ->setProperty('hidden', true)
                                ->save();
    $regexIndex['ROOT']->relateTo($T[-1], 'INDEXED')->save();
    
    $last     = $client->makeNode()->setProperty('token', 'T_END')
                                   ->setProperty('code', '/**/')
                                   ->setProperty('line', $line)
                                   ->setProperty('hidden', true)
                                   ->save();

    $T[-1]->relateTo($T[0], 'NEXT')->setProperty('__FILE__', true)->save();
    $previous->relateTo($last, 'NEXT')->setProperty('__FILE__', true)->save();
    
    $last2     = $client->makeNode()->setProperty('token', 'T_END')
                                    ->setProperty('code', '/* * */')
                                    ->setProperty('line', $line)
                                    ->setProperty('hidden', true)
                                    ->save();

    $last->relateTo($last2, 'NEXT')->setProperty('__FILE__', true)->save();

    $client->save_chunk();
    
    return $Tid;
}
?>