#!/usr/bin/env php
<?php
use Everyman\Neo4j\Client,
	Everyman\Neo4j\Index\NodeIndex,
	Everyman\Neo4j\Relationship,
	Everyman\Neo4j\Node,
	Everyman\Neo4j\Gremlin;

include_once(dirname(__DIR__).'/library/Autoload.php');
spl_autoload_register('Autoload::autoload_library');

$args = $argv;

if ($id = array_search('-v', $args)) {
    define('VERBOSE', true);
} else {
    define('VERBOSE', false);
}

if ($id = array_search('-r', $args)) {
    define('RECURSIVE', true);
} else {
    define('RECURSIVE', false);
}

if ($id = array_search('-f', $args)) {
    $filename = $args[$id + 1];
    
    process_file($filename);
} elseif ($id = array_search('-d', $args)) {
    $dir = $args[$id + 1];
    
    if ($dir{strlen($dir) - 1} == '/') {
        $dir = substr($dir, 0, -1);
    }
    
    process_dir($dir);
} else {
    print "No file to process. Aborting\n";
    die();
}

function process_dir($dir) {

    $dirr = opendir($dir);
    while ($filename = readdir($dirr)) {
        if ($filename{0} == '.') { continue; }
        
        if (is_dir($dir.'/'.$filename)) {
            if (RECURSIVE) {
                process_dir($dir.'/'.$filename);
            }
        } else {
            if (substr($filename, -4) != '.php') { continue; }
            print $dir.'/'.$filename."\n";
            process_file($dir.'/'.$filename);
        }
    }
}

function process_file($filename) {
    
    if (!file_exists($filename)) {
        print "'$filename' doesn't exists. Aborting\n";
        die();
    }
    
    $shell = shell_exec('php -l '.$filename.' 2>&1');
    if (trim($shell) != 'No syntax errors detected in '.$filename) {
        print "Error : |$shell|\n";
        return false;
    }
    
    $php = file_get_contents($filename);
    $file = realpath($filename);
    $tokens = token_get_all($php);
    
    $client = new Client();

    // @doc delete old tokens
    $queryTemplate = "g.V.has('file', '$file').outE.each{ g.removeEdge(it); }";
    $params = array('type' => 'IN');
    $query = new Gremlin\Query($client, $queryTemplate, $params);
    $query->getResultSet();
    
    $queryTemplate = "g.V.has('file', '$file').each{ g.removeVertex(it); }";
    $params = array('type' => 'IN');
    $query = new Gremlin\Query($client, $queryTemplate, $params);
    $edges = $query->getResultSet();

    $racines = new NodeIndex($client, 'racines');
    $regex = Tokenizer\Token::$types; 
    $regexIndex = array();
    foreach($regex as $r) {
        $regexIndex[$r] = $client->makeNode()->setProperty('token', $r)
                                             ->setProperty('code', 'Index for '.$r)
                                             ->setProperty('file', $filename)
                                             ->setProperty('index', 'yes')
                                             ->save();
        $racines->add($regexIndex[$r], 'token', $r);
    }
        $regexIndex['DELETE'] = $client->makeNode()->setProperty('token', 'DELETE')
                                                 ->setProperty('code', 'Index for DELETE')
                                                 ->setProperty('file', $filename)
                                                 ->setProperty('index', 'yes')
                                                 ->save();
        $racines->add($regexIndex['DELETE'], 'token', 'DELETE');
    
    // load new tokens
    $line = 0;
    $TPHP = array(";" => 'T_SEMICOLON',
                  "=" => 'T_EQUAL',
                  "+" => 'T_PLUS',
                  "-" => 'T_MINUS',
                  "*" => 'T_STAR',
                  "/" => 'T_SLASH',
                  "%" => 'T_PERCENTAGE',
                  "(" => 'T_OPEN_PARENTHESIS',
                  ")" => 'T_CLOSE_PARENTHESIS',
                  "!" => 'T_BANG',
                  "[" => 'T_OPEN_BRACKET',
                  "]" => 'T_CLOSE_BRACKET',
                  "{" => 'T_OPEN_CURLY',
                  "}" => 'T_CLOSE_CURLY',
                  '.' => 'T_DOT',
                  ',' => 'T_COMMA',
                  '@' => 'T_AT',
                  '?' => 'T_QUESTION',
                  ':' => 'T_COLON',
                  '>' => 'T_GREATER',
                  '<' => 'T_SMALLER',
                  '&' => 'T_AND',
                  '^' => 'T_OR',
                  '|' => 'T_XOR',
                  '&&' => 'T_ANDAND',
                  '||' => 'T_OROR',
                  '"' => 'T_QUOTE',
                  '"_CLOSE' => 'T_QUOTE_CLOSE',
                  '$' => 'T_DOLLAR',
                  '`' => 'T_SHELL_QUOTE',
                  '`_CLOSE' => 'T_SHELL_QUOTE_CLOSE',
                  '~' => 'T_TILDE',
                  );
    
    $atoms = array( 'T_STRING'                   => 'String', 
                    'T_CONSTANT_ENCAPSED_STRING' => 'String', 
                    'T_CONSTANT_ENCAPSED_STRING' => 'String', 
                    'T_ENCAPSED_AND_WHITESPACE'  => 'String',
                    'T_INLINE_HTML'              => 'String',
                    'T_VARIABLE'                 => 'Variable',
                    'T_STRING_VARNAME'           => 'Variable',
                    'T_LNUMBER'                  => 'Integer', 
                    'T_NUM_STRING'               => 'Integer',
                    'T_DNUMBER'                  => 'Float', 
                    'T_CLASS_C'                  => 'Magicconstant', 
                    'T_FUNC_C'                   => 'Magicconstant', 
                    'T_DIR'                      => 'Magicconstant', 
                    'T_FILE'                     => 'Magicconstant', 
                    'T_LINE'                     => 'Magicconstant', 
                    'T_METHOD_C'                 => 'Magicconstant', 
                    'T_NS_C'                     => 'Magicconstant', 
                    );
            
    
    $count = array();
    foreach($tokens as $id => $token) {
        if ($token[0] == T_WHITESPACE)  { unset($tokens[$id]); }
        if ($token[0] == T_COMMENT)     { unset($tokens[$id]); }
        if ($token[0] == T_DOC_COMMENT) { unset($tokens[$id]); }
    }
    $tokens = array_values($tokens);
    
    $nb = count($tokens);
    $Tid = -1;
    $root = 0;
    for($id = 0; $id < $nb; $id++) {
        if (empty($tokens[$id])) { 
            continue; 
        }
        $Tid++;
        $token = $tokens[$id];
        $to_index = true;
        
        if (is_array($token)) {
            if (token_name($token[0]) == 'T_BREAK' && is_string($tokens[$id + 1]) && $tokens[$id + 1] == ';') {
                $T[$Tid] = $client->makeNode()->setProperty('token', token_name($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2])
                                              ->setProperty('file', $file)->save();
                $regexIndex["_Break"]->relateTo($T[$Tid], 'INDEXED')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_LNUMBER')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('file', $file)
                                              ->setProperty('atom', 'Void')->save();

                $to_index = false;
            } elseif (token_name($token[0]) == 'T_CLOSE_TAG' && isset($tokens[$id + 1]) && is_array($tokens[$id + 1])  && token_name($tokens[$id + 1][0]) == 'T_OPEN_TAG') {
                $id++;
                continue 1;
            } else {
                $T[$Tid] = $client->makeNode()->setProperty('token', token_name($token[0]))
                                              ->setProperty('code', $token[1])
                                              ->setProperty('line', $token[2])
                                              ->setProperty('file', $file);
            }
            $T[$Tid]->save();
            
            if (token_name($token[0]) == 'T_STRING' && (strtolower($token[1]) == 'true' || strtolower($token[1]) == 'false')) {
                $T[$Tid]->setProperty('atom', 'Boolean')->save();
                $to_index = false;
            } elseif (isset($atoms[token_name($token[0])])) {
                $T[$Tid]->setProperty('atom', $atoms[token_name($token[0])])->save();
            }
            
            $token_value = token_name($token[0]);
            if ($token_value == 'T_OPEN_CURLY') {
                $token_value = 'T_CURLY_OPEN';
                
            }
            $line = $token[2];
        } else {
            if (!isset($TPHP[$token])) {
                print("No TPHP for '{$token}'\n");
                $TPHP[$token] = max($TPHP) + 1;
            }

            $token_value = $TPHP[$token];
            if (in_array($TPHP[$token], array('T_QUOTE', 'T_SHELL_QUOTE'))) {
                @$count[$TPHP[$token]]++;
                if ($count[$TPHP[$token]] % 2 == 0) {
                    $token .= '_CLOSE';
                    $token_value .= '_CLOSE';
                }
            }
            
            if ($token == '{' && $tokens[$id + 1] == '}') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->setProperty('file', $file)
                                              ->setProperty('atom', 'Block')->save();

                $void   = $client->makeNode()->setProperty('token', 'T_VOID')
                                             ->setProperty('code', 'void')
                                             ->setProperty('line', $line)
                                             ->setProperty('file', $file)
                                             ->setProperty('atom', 'Void')->save();

                $T[$Tid]->relateTo($void, 'CODE')->save();
                unset($tokens[$id + 1]);
                $to_index = false;
            } elseif ($token == '(' && $tokens[$id + 1] == ')') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->setProperty('file', $file)->save();
                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('file', $file)
                                              ->setProperty('atom', 'Arguments')->save();

                $to_index = false;
            } elseif ($token == '{' && $tokens[$id + 1] == ';') {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->setProperty('file', $file)->save();
                $previous->relateTo($T[$Tid], 'NEXT')->save();
                $previous = $T[$Tid];
                $regexIndex["Block"]->relateTo($T[$Tid], 'INDEXED')->save();                
                
                $Tid++;
                $T[$Tid] = $client->makeNode()->setProperty('token', 'T_VOID')
                                              ->setProperty('code', 'void')
                                              ->setProperty('line', $line)
                                              ->setProperty('file', $file)
                                              ->setProperty('atom', 'Void')->save();

                $to_index = false;
            } elseif ($token == '{' && $tokens[$id + 1] == ';' && $tokens[$id + 2] == '}' ) {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->setProperty('file', $file)
                                              ->setProperty('atom', 'Block')->save();

                $void   = $client->makeNode()->setProperty('token', 'T_VOID')
                                             ->setProperty('code', 'void')
                                             ->setProperty('line', $line)
                                             ->setProperty('file', $file)
                                             ->setProperty('atom', 'Void')->save();

                $sequence = $client->makeNode()->setProperty('token', 'T_SEMICOLON')
                                               ->setProperty('code', ';')
                                               ->setProperty('line', $line)
                                               ->setProperty('file', $file)
                                               ->setProperty('atom', 'Sequence')->save();

                $T[$Tid]->relateTo($sequence, 'CODE')->save();
                $sequence->relateTo($void, 'CODE')->save();

                unset($tokens[$id + 1]);
                unset($tokens[$id + 2]);
                $to_index = false;
            } else {
                $T[$Tid] = $client->makeNode()->setProperty('token', $TPHP[$token])
                                              ->setProperty('code', $token)
                                              ->setProperty('line', $line)
                                              ->setProperty('file', $file)->save();
            }
    
            $T[$Tid]->save();
        }
    
        // test is for booleans. 
        if ($to_index) {
            $regex = Tokenizer\Token::$types; 
            foreach($regex as $r) {
                $class = "Tokenizer\\$r";
                if (in_array($token_value, $class::$operators)) { 
                    $regexIndex[$r]->relateTo($T[$Tid], 'INDEXED')->save();
                }
            }
        }
        
        if (!isset($previous)) {
            $previous = $T[$Tid];
        } else {
            $previous->relateTo($T[$Tid], 'NEXT')->save();
            $previous = $T[$Tid];
            
            // Saving on memory, we don't keep the previous ones.
            if ($Tid > 1) {
                unset($T[$Tid - 1]);
            }
        }
    }
    
    $T[0]->setProperty('root', 'true')->save();
    
    $T[-1] = $client->makeNode()->setProperty('token', 'T_ROOT')
                                ->setProperty('code', '/**/')
                                ->setProperty('line', 0)
                                ->setProperty('file', $file)
                                ->setProperty('hidden', true)
                                ->save();
    
    $last     = $client->makeNode()->setProperty('token', 'T_END')
                                   ->setProperty('code', '/**/')
                                   ->setProperty('line', $line)
                                   ->setProperty('file', $file)
                                   ->setProperty('hidden', true)
                                   ->save();
                                   
    $T[-1]->relateTo($T[0], 'NEXT')->setProperty('__FILE__', true)->save();
    $previous->relateTo($last, 'NEXT')->setProperty('__FILE__', true)->save();
    
    $last2     = $client->makeNode()->setProperty('token', 'T_END')
                                    ->setProperty('code', '/* * */')
                                    ->setProperty('line', $line)
                                    ->setProperty('file', $file)
                                    ->setProperty('hidden', true)
                                    ->save();
    $last->relateTo($last2, 'NEXT')->setProperty('__FILE__', true)->save();
}
?>