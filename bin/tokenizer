#!/usr/bin/env php
<?php
use Everyman\Neo4j\Client,
	Everyman\Neo4j\Index\NodeIndex,
	Everyman\Neo4j\Relationship,
	Everyman\Neo4j\Node,
	Everyman\Neo4j\Gremlin,
	Tokenizer\Token;

include_once(dirname(__DIR__).'/library/Autoload.php');
spl_autoload_register('Autoload::autoload_library');

$args = $argv;
$begin = microtime(true);

if ($id = array_search('-v', $args)) {
    define('VERBOSE', true);
} else {
    define('VERBOSE', false);
}

if ($id = array_search('-s', $args)) {
    define('SHUFFLE', true);
} else {
    define('SHUFFLE', false);
}

if ($id = array_search('-p', $args)) {
    $project = $args[$id + 1];
} else {
    $project = 'default';
}

if (!file_exists('./projects/'.$project.'/config.ini')) {
    print "No such config.ini in project '$project'. Aborting\n";
    die();
}

$config = parse_ini_file('./projects/'.$project.'/config.ini');

$begin_time = microtime(true);
if (empty($config['phpversion'])) {
    $classes = Token::getTokenizers(PHP_VERSION);
    $config['phpversion'] = PHP_VERSION;
} else {
    $classes = Token::getTokenizers($config['phpversion']);
}

if (file_exists('classes.php')) {
    include('classes.php');
} else {
    if (SHUFFLE) {
        shuffle($classes);
    }
    
    file_put_contents('classes.php', '<?php '."\n".'$classes = '.var_export($classes, true).'; ?>');
}

$log = new Log('tokenizer');
$log->log( "Starting time : ".date('r'));

$client = new Client();

$regex = array();
foreach($classes as $class) {
    $new = "Tokenizer\\$class";
    
    $r = Tokenizer\Token::getInstance($new, $client, $config['phpversion']);
    if (is_null($r)) {
        display("Ignore $new\n");
        // ignore 
    } elseif ($new == 'Tokenizer\\FunctioncallArray') {
        $regex[$class] = $r;
    } elseif ($new == 'Tokenizer\\Sequence') {
        $regex[$class] = $r;
    } elseif ($r->checkRemaining()) {
        $regex[$class] = $r;
    } else {
        display("Ignore $new in else\n");
    }
}

$log->log( "Finished loading classes");

$server_stat = new Stats($client);
$server_stat->collect();
$stats = array('token_in' => $server_stat->tokens_count, 'token_out' => 2, 
               'relation_in' => $server_stat->relations_count, 'relation_out' => 4,
               'project' => $project);

$total = Tokenizer\Token::countTotalToken();
//$count = $total + 1;
$count = Tokenizer\Token::countLeftToken() + 1;

$extra_rounds = 4;
$prev = array();
for($i = 0; $i < $extra_rounds + 1; $i++) {
    $prev[$i] = $count + $i;
}
$round = 0;
$cost = 0;


$wbegin = microtime(true);
$regex_time = 0;
$regex_next = $regex;
$end = microtime(true);
$log->log( "initialisation : ".(($end - $begin) * 1000));

while(check_prev($prev, $extra_rounds)) { 
    $rbegin = microtime(true);
    $round++;
    $log->log("round $round)");
    
    array_unshift($prev, $count);

    $regex = $regex_next;
    $regex_next = array();
    foreach($regex as $name => $r) {
        $begin = microtime(true);
        if ($r->check() || in_array($name , array("FunctioncallArray", 'Sequence'))) {
            $regex_next[$name] = $r;
        }
        $end = microtime(true);
        
        $regex_time += $end - $begin;

        $log->log( get_class($r)."\t".(($end - $begin) * 1000)."\t".Token::leftInIndex($name));
    }
    unset($precedence);
    Token::finishSequence();
    
    $rend = microtime(true);
    $begin = microtime(true);
    $log->log("round : $round\t".(($rend - $rbegin) * 1000));
    $cost += count($regex_next);
    $log->log("cost : $cost");

    if (isset($count)) {
        $count_prev = $count;
        $count = Token::countLeftNext();
    } else {
        $count = Token::countLeftNext();
        $count_prev = $count;
    }
    

    if (isset($count_file)) {
        $count_file_prev = $count_file;
        $count_file = Token::countFileToProcess();
    } else {
        $count_file = Token::countFileToProcess();
        $count_file_prev = $count_file;
    }
    
    $end = microtime(true);
    $log->log("countLeftNext time : ".(($end - $begin) * 1000)."");

    $log->log("Remaining token to process : $count (".($count - $count_prev).")");
    $log->log("Remaining files to process : $count_file (".($count_file - $count_file_prev).")");
    $log->log("Remaining regex : ".count($regex_next)." (".(count($regex) - count($regex_next)).")");
    
    if ($count > 3) {
        display( "$round) Remains $count of $total tokens to process! \n");
    } else {
        display( "$round) All $total tokens have been processed! \n");
        break 1;
    }
    
}

$wend = microtime(true);
$log->log("Total while $round)\t".(($wend - $wbegin)*1000)."");
$log->log("Total regex time\t".(($regex_time) * 1000)."");
$log->log("final cost : $cost");

$server_stat->collect();
$stats['token_out'] = $server_stat->tokens_count;
$stats['relation_out'] = $server_stat->relations_count;

Token::cleanHidden();

$end_time = microtime(true);
display("Total time : ".number_format(($end_time - $begin_time) * 1000, 2, '.', ' ')."ms\n");
$log->report('tokenizer', $stats);
// @todo display checks processed

function check_prev($prev, $extra_rounds) {
    $b = false;
    for($i = 0; $i < $extra_rounds; $i++) {
        $b = $b || ($prev[$i + 1] > $prev[$i]);
    }
    return $b;
}

function array_flatten($array, $level = 1) {
    $r = array();
    
    foreach($array as $a) {
        if ($level > 1 && is_array($a)) {
            $a = array_flatten($a, $level - 1);
        }
        $r = array_merge($r, $a);
    }
    
    return $r;
}

function display($message) {
    if (VERBOSE) {
        print $message;
    }
    // @todo put in log too ? 
}
?>