#!/usr/bin/env php
<?php
use Everyman\Neo4j\Client,
	Everyman\Neo4j\Index\NodeIndex,
	Everyman\Neo4j\Relationship,
	Everyman\Neo4j\Node,
	Everyman\Neo4j\Gremlin,
	Tokenizer\Token;

include_once(dirname(__DIR__).'/library/Autoload.php');
spl_autoload_register('Autoload::autoload_library');

$log = new Log('fullcode');

$client = new Client();

$offset = 0000;
$limit = 1100000;
$end = $offset + $limit;

print "Work on $limit tokens\n";
$log->log("Limit\t$limit");
//.has('fullcode', null)
$result = query("g.V[$offset..$end].hasNot('atom', null).filter{!(it.token in ['E_CLASS', 'E_FUNCTION', 'E_NAMESPACE', 'E_FILE', 'T_INDEX', 'T_ROOT', 'T_END'])}.has('fullcode', null).sideEffect{ it.fullcode = 'Not available.'}.iterate()");

$tokens = array( 'Float', 'Integer', '_Function', '_Global', 'String',  'Real', "Void", 'Identifier', '_Return', 'Multiplication', 
                 'Variable', 'Concatenation', 'Comparison', '_Break', 'Magicconstant', '_Throw', 
                 'Parenthesis', 'Addition', 'Arguments', 'Functioncall', 'Parenthesis', 'Assignation', '_Case', '_Default', '_Include', 'Noscream', 
                 'Preplusplus', 'Bitshift', 'Postplusplus', 'Sign', 'Boolean', '_Array', '_Static', '_Final', 'Not', 'Reference', 'Keyvalue', '_Ppp', 
                 'Property', 'Methodcall', 'Logical', 'Ternary', 'Arrayappend', 'Staticmethodcall', 'Staticproperty', 'Staticconstant', 
                 '_New', 'Cast', 'Sequence', 'Block', 'Ifthen', '_Foreach', '_While', '_Dowhile', '_Abstract', '_Continue', 'RawString', 'Phpcode', 
                 '_For', '_Class', '_Switch', 'Nsname', '_Namespace', '_Clone', 'Typehint', '_Const', '_Try', '_Use', '_Interface', '_Instanceof',
                 '_Catch', 'SequenceCaseDefault', '_Var'   );
$tokens = array('Arguments');

$prev = $limit + 2;
$current = $limit + 1;

// synopsis : first round, either do the fullcode, or link it to some index. subsequent rounds, only use the 

$round = 0;
while ($current < $prev && $current > 0) {
    print "\n";
    $round++;
    $log->log("round\t$round");
    foreach($tokens as $id => $token) {
        $atom = str_replace('_', '', $token);
        $class = "Tokenizer\\".$token;
        $object = new $class($client);
        $query = "c = 0; t = 0; g.V[$offset..$end].hasNot('atom', null).filter{!(it.token in ['E_CLASS', 'E_FUNCTION', 'E_NAMESPACE', 'E_FILE', 'T_INDEX', 'T_ROOT', 'T_END'])}.has('fullcode', 'Not available.').has('atom', '".$atom."').sideEffect{t++; }.filter{it.out.has('fullcode', 'Not available.').count() == 0}.each{ ".$object->fullcode()."; c++; }; t - c;";
        $result = query($query);

        $log->log("$token\t".$result[0][0]);
        if ($result[0][0] == 0) {
            unset($tokens[$id]);
        }
        print ".";
    }

    $result = query("m = [:]; g.V[$offset..$end].hasNot('atom', null).has('fullcode', 'Not available.').groupCount(m){it.atom}.iterate(); m.each{}");
    $r = $result->toArray();

    $prev = $current;
    $current = 0;
    foreach($r as $s) { $current += $s[0]; }
    $log->log("Left token\t$current");
}

$log->log("Left token\t$current");
if ($current > 0) {
    foreach($r as $t => $s) { 
        $log->log("$t\t".$s[0]);
    }
}
print "\nFinished with $current tokens left.\n";    

function query($query) {
    global $client;
    $params = array('type' => 'IN');
    $query = new Gremlin\Query($client, $query, $params);
    return $query->getResultSet();
}

?>