#!/usr/bin/env php
<?php
use Everyman\Neo4j\Client,
	Everyman\Neo4j\Index\NodeIndex,
	Everyman\Neo4j\Relationship,
	Everyman\Neo4j\Node,
	Everyman\Neo4j\Gremlin,
	Tokenizer\Token;

include_once(dirname(__DIR__).'/library/Autoload.php');
spl_autoload_register('Autoload::autoload_library');

$args = $argv;
$begin = microtime(true);

if ($id = array_search('-v', $args)) {
    define('VERBOSE', true);
} else {
    define('VERBOSE', false);
}

if ($id = array_search('-s', $args)) {
    define('SHUFFLE', true);
} else {
    define('SHUFFLE', false);
}

$begin_time = microtime(true);
$classes = array(
//    'Magicconstant',
    'Variable',     // Fait 
    'Halt',         // Fait
    'Variabledollar',// Fait 
//    'Integer',
//    'Float',
    'Boolean',      // Fait
    'Sign',         // Fait
    '_Array',       // Fait
    '_Arraydollarcurly',// Fait
    'Property',     // Fait
    'Keyvalue',     // Fait
    '_Function',    // Fait
    'Staticproperty',// Fait
    'Logical',      // Fait
    'Heredoc',      // Fait
    'Not',          // Fait
    'Cast',         // Fait
    'Reference',    // Fait
    'Arrayappend',  // Fait
    '_Instanceof',  // Fait
    '_Break',       // Fait
    '_Continue',    // Fait
    'Label',        // Fait
    '_Goto',        // Fait
    '_New',         // Fait
    '_Global',      // Fait
    'Nsname',       // Fait
    '_Namespace',   // Fait
    '_Include',     // Fait
    'Preplusplus',  // Fait
    'Postplusplus', // Fait
    'Noscream',     // Fait
    'Parenthesis',  // Fait
    '_Clone',       // Fait
    'Arguments',    // Fait
    'ArgumentsNoParenthesis', // Fait
    'ArgumentsNoComma', // Fait
    'ArgumentsArray', 
    'Functioncall', // Fait
    'FunctioncallArray',
    'Methodcall',   // Fait
    'Staticmethodcall', // Fait
    'Staticconstant',//Fait
    'Multiplication',// Fait
    'Addition',     // Fait
    'Bitshift',     // Fait
    'Concatenation', // Fait
    'ConcatenationAtom', 
    'String',       // Fait
    '_Var',         // Fait
    '_Ppp',         // Fait
    '_Static',      // Fait
    'Assignation',  // Fait
    'Comparison',   // Fait
    'Ternary',      // Fait
    'Constant',     // Fait
    '_Return',      // Fait
    '_Declare',     // Fait
    '_Const',       // Fait
    'Block',        // Fait
    'Shell',        // Fait
    '_Interface',   // Fait
    '_Class',       // Fait
    '_Abstract',    // Fait
    '_Final',       // Fait
    'Typehint', 
    '_Throw',       // Fait
    '_Case',        // Fait
    '_Default',     // Fait
    '_Switch',      // Fait
    'Ifthen',
    'IfthenElse',   // Fait
    '_Foreach',
    '_For',
    '_While',
    '_Dowhile',     // Fait
    '_Catch',       // Fait
    '_Try',         // Fait
    'Sequence',     // Fait
    'SequenceAtom',
    'SequenceCaseDefault',
    'Phpcodemiddle',// Fait
    'Phpcode',      // Fait
    'Void',
);

if (file_exists('classes.php')) {
    include('classes.php');
} else {
    if (SHUFFLE) {
        shuffle($classes);
    }
    
    file_put_contents('classes.php', '<?php '."\n".'$classes = '.var_export($classes, true).'; ?>');
}

$client = new Client();

$regex = array();
foreach($classes as $class) {
    $new = "Tokenizer\\$class";
    
    $r = new $new($client);
    if ($r->checkRemaining()) {
        $regex[$class] = $r;
    }
}

$total = Tokenizer\Token::countTotalToken();
$count = Tokenizer\Token::countLeftToken() + 1;

$extra_rounds = 5;
$prev = array();
for($i = 0; $i < $extra_rounds + 1; $i++) {
    $prev[$i] = $count + $i;
}
$round = 0;
$cost = 0;

$log = fopen('log/analyzer.log', 'w');

$wbegin = microtime(true);
$regex_time = 0;
$regex_next = $regex;
$end = microtime(true);
fwrite($log, "initialisation : ".(($end - $begin) * 1000)."\n");

while(check_prev($prev, $extra_rounds)) { 
    $rbegin = microtime(true);
    $round++;
    fwrite($log, "round $round)\n");
    
    array_unshift($prev, $count);

    $regex = $regex_next;
    $regex_next = array();
    foreach($regex as $name => $r) {
        $begin = microtime(true);
        if ($r->check()) {
            $regex_next[$name] = $r;
        }
        $end = microtime(true);
        
        $regex_time += $end - $begin;

        fwrite($log, get_class($r)."\t".(($end - $begin) * 1000)."\t".Token::leftInIndex($name)."\n");
    }
    unset($precedence);
    Token::finishSequence();
                
    $rend = microtime(true);
    $begin = microtime(true);
    fwrite($log, "round : $round\t".(($rend - $rbegin)*1000)."\n");
    $cost += count($regex_next);
    fwrite($log, "cost : $cost\n");

    $count = Token::countLeftNext();
    $end = microtime(true);
    fwrite($log, "countLeftNext time : ".(($end - $begin) * 1000)."\n");

    fwrite($log, "Remaining token to process : $count\n");
    fwrite($log, "Remaining files to process : ".Token::countFileToProcess()."\n");
    fwrite($log, "Remaining regex : ".count($regex_next)." (".(count($regex) - count($regex_next)).")\n");
    
    if ($count > 3) {
        display( "$round) Remains $count of $total tokens to process! \n");
    } else {
        display( "$round) All $total tokens have been processed! \n");
        if (Token::countLeftNext() > 3) {
//            Token::finishSequence();
        }
        break 1;
    }
    
}
$wend = microtime(true);
fwrite($log, "Total while $round)\t".(($wend - $wbegin)*1000)."\n");
fwrite($log, "Total regex time\t".(($regex_time) * 1000)."\t\n");
fwrite($log, "final cost : $cost\n");

Token::cleanHidden();

$end_time = microtime(true);
display("Total time : ".number_format(($end_time - $begin_time) * 1000, 2, '.', ' ')."ms\n");
fwrite($log, "total script \t".(($end_time - $begin_time)*1000)."\n");
fclose($log);
// @todo display checks processed

function check_prev($prev, $extra_rounds) {
    $b = false;
    for($i = 0; $i < $extra_rounds; $i++) {
        $b = $b || ($prev[$i + 1] > $prev[$i]);
    }
    return $b;
}

function array_flatten($array, $level = 1) {
    $r = array();
    
    foreach($array as $a) {
        if ($level > 1 && is_array($a)) {
            $a = array_flatten($a, $level - 1);
        }
        $r = array_merge($r, $a);
    }
    
    return $r;
}

function display($message) {
    if (VERBOSE) {
        print $message;
    }
    // @todo put in log too ? 
}
?>